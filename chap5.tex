\chapter{Future Work}

The work of this thesis, building upon \cite{marco}, establishes a baseline for the speed that can be expected of a system built using the split-value design. Additional work may build upon the optimizations described in this thesis to provide further performance gains or experiment with using other languages and platforms to compare them to our Python implementation. Work is also being done to improve the design by supporting additional fault tolerance. Finally, a real-life deployed version of this system must also include mechanisms for secure channels and key exchange as part of the election setup.

\section{Performance Considerations}

While the work in this thesis produced a $10 \times$ speedup over the reference prototype, there is good potential for even more performance gains. For example, the results in section \ref{perf:crypto:hashenc} suggest that our commitment scheme may become significantly faster by writing code with native hardware support.

Given the current implementation, improvements to performance may be guided by the following goals.
\begin{itemize}
\item \emph{Construct a more accurate model for where runtime is going}. Studying the profiler output for each mixserver is a good first step; even more informative would be a way to visualize the amount of time spent by each mixserver in each parallelized mix or proof phase. Another metric of interest is the duration of time that each server spends waiting for other servers and the remote procedure calls that cause such waiting to occur.
\item \emph{Obtain accurate numbers on the amount of time spent in crypto-related operations, versus data serialization and message passing}. Throughout most of the optimization process, the actual ``number-crunching'' of the crypto-related operations consumed far less time than the overhead of data serialization and message passing. After numerous optimizations, the two appear components relatively even in runtime. However, experiments that attempt to more accurately measure this (for example, by replacing a crypto function with a fast, constant time statement like \texttt{return 0}) were inconclusive. Accurate results here will provide valuable insight on the maximum benefit to be derived from optimizing each component of the system.
\item \emph{Compare the performance of the split-value system to that of comparable systems}. Detailed performance numbers are unfortunately not availabe in most of the electronic voting and mixnet literature. However, it may be informative to profile existing implementations of systems such as \cite{votebox, adida-helios} and implement mixnet schemes designed for efficiency such as \cite{chase13} for comparison.
\end{itemize}

Python is often criticized for being a slow language; statically-checked, strongly-typed languages compiled directly into machine code may perform much better and take advantage of extensions such as CilkPlus for C/C++. On the other hand, the potential for performance gains by using a language like C++ needs to be weighed against the increases in code complexity and difficulty in reading and debugging. Python's C bindings may also be used for specific functions that could benefit from great optimization while leaving the majority of the codebase intact.

\section{Fault Tolerance}

In a production environment, servers (which may be election officials' laptops) may crash, power may go out, and an election official might even forget to bring her laptop. Data may be corrupted in transit or on disk. A server may be ejected from the mixnet if it is discovered to be dishonest. A robust, fault-tolerant system is needed to ensure that the election can still run smoothly despite these failures. Possible improvements to fault tolerance include the following.
\begin{itemize}
\item \emph{Replicate and persist the secure bulletin board to disk}. The secure bulletin board ultimately contains all of the information generated by the mixservers for the mix and proof phases of the election. This information should be replicated and persisted to disk so that no single server failure causes this information to be lost.
\item \emph{Remove central points of failure, such as the controller}. Because the controller dictates the progression of the entire election and all other servers take instructions from it, a failure of the controller will cause the entire system to stop. The controller may be designed as a replicated state machine, or it may be removed altogether in a system where the mixservers collectively communicate among each other and advance the election.
\item \emph{Ensure that no data is corrupted during transmission}. This may be accomplished via message authentication codes or digital signatures, which also provide security guarantees as described in the next section.
\end{itemize}
Work by Danna Kelmer at NYU begins to address fault tolerance in the system.

\section{Secure Channels and Key Exchange}

Ultimately, the system must run on multiple machines connected to some network. Despite precautions to ensure the integrity of the network (e.g. private network, wired connections only with wireless adapters off), cryptographically secure channels are necessary and a relatively simple way to ensure end-to-end encryption and authentication. The various public-key and symmetric encryption and authentication functions should be compared for their security and performance characteristics, and the process of key exchange should be designed to be done when the election is setup the day before.
