\chapter{Electronic Voting Systems and Technologies}

% TODO: Survey the other electronic voting systems and the crypto used in them, such as helios, votebox, starvote, wombat.

% TODO: Survey mixnets for design and performance.

% Ballot casting

We now turn to an overview of existing electronic voting systems and technologies, focusing on systems that provide end-to-end verifiability. First, we discuss common design patterns found in end-to-end verifiable voting systems. Then, we present an overview of the cryptographic techniques used to achieve verifiability while maintaining voter privacy. We conclude with studies of voting systems that have been implemented in practice.

\section{Design of End-to-End Voting Systems}

Recall from [REF PREVIOUS CHAPTER] that an \emph{end-to-end verifiable} voting system is defined by three characteristics: cast-as-intended, recorded-as-cast, and tallied-as-recorded. The first two conditions must be verified by the voter herself; our desire for incoercibility requires that no third-party may verify these properties on behalf of the voter. The last condition may be verified by anyone in the public, including someone who did not participate in the election. By verifying all three conditions, any voter may verify that her vote was counted properly and that the declared election outcome is honest.

A typical election consists of two phases.
\begin{enumerate}
\item \emph{The voting phase}. In the voting phase, a voter indicates her choices for a given election by casting a ballot. The voter's ballot is typically encrypted; we must provide a proof to the voter that the encryption of the ballot faithfully represents her choices. For the purposes of this discussion, we will assume that the electronic ballot is accompanied by a paper trail and the voter is given a receipt that she may take out of the polling site. We will also assume that privacy is guaranteed inside the voting booth; even with the cooperation of the voter, no one else may observe the voter's actions inside the voting booth.
\item \emph{The tallying phase}. In the tallying phase, the election officials tally the set of encrypted ballots to produce an election outcome. We require that they do so without compromising the privacy of any individual voter; otherwise, a corrupt election official can act as a coercer. We also require that the election officials provide a proof that the announced election outcome is honest.
\end{enumerate}

In this section, we examine designs that are used to ensure each of these conditions of an end-to-end verifiable voting system is met.

\subsection{A Secure Bulletin Board}

Central to the design of end-to-end verifiable voting systems is a publicly viewable secure bulletin board. There may be additional restrictions imposed on the actions that may be taken on it; for example, the bulletin board may be append-only.

In general, encrypted votes may be posted to the secure bulletin board along with identifiable information about a voter as long as the ciphertext provides no information about the underlying plaintext to anyone, including the voter herself. This means, for example, that the voter cannot know the randomization values used in the encryption; otherwise, a voter could prove her vote to a coercer.

The secure bulletin board also contains a proof of the election outcome, thereby allowing anyone to verify it. This can be accomplished by listing the plaintext votes after removing the associations between the plaintexts and voter IDs or by posting a zero-knowledge proof of correctness for the decryption of the tallied votes.

\subsection{Cast-as-Intended Behavior}

To ensure cast-as-intended behavior, we use the \emph{``cast or challenge''} protocol as described in [CITE NEFF, BENALOH]. After a voter has made her selections, the system encrypts them using some randomness and prints a receipt containing a cryptographic hash of the ciphertext. The system may additionally print a paper copy of the ballot containing more information which the voter must deposit into the ballot box before leaving.

The voter then has the option to either \emph{cast} the ballot or \emph{challenge} the system.
\begin{itemize}
\item The voter chooses to cast her ballot. She deposits the printout into the ballot box.
\item The voter chooses to challenge the system. In this case, the system reveals the ciphertext and the randomization values used to produce it. The voter can verify that encryption of her vote with the given randomization produces the desired ciphertext and that the commitment to the ciphertext on the printout is correct. Should the voter choose this option, the ballot is spoiled. She must ask the system for a new randomized encryption of her selection, with which she has the option to cast or challenge again.
\end{itemize}

In this scheme, the system must output a commitment to some ciphertext before it knows whether the voter will choose to cast or challenge. A skeptical voter may choose to challenge multiple times, thereby increasing the probability of catching a malicious system. Because of our privacy assumptions about the polling site, no one else may observe the voter while she issues a challenge to the system. However, a ballot that the voter challenges must be spoiled because the challenge process reveals how the ciphertext is constructed; a voter could use this information to prove how she voted after leaving the polling site if the encrypted votes are publicly posted.

\subsection{Recorded-as-Cast Behavior}

To ensure recorded-as-cast behavior, we provide the voter with a way to check that her vote is accurately recorded on the secure bulletin board. Using her paper receipt, the voter can find her voter ID on the secure bulletin board and verify that the hash value of the posted ciphertext corresponds to the hash value on her receipt. Combined with the cast or challenge protocol of the previous section, the voter can verify that her selection has been correctly recorded on the secure bulletin board. However, she cannot prove to anyone how she voted with just the ciphertext and corresponding hash value.

\subsection{Tallied-as-Recorded Behavior}

To ensure tallied-as-recorded behavior, the system provides a proof that the encrypted votes recorded on the secure bulletin board correspond to the election outcome. In general, there are two ways to accomplish this: either the ciphertexts are combined to produce the election tally using homormorphic encryption, or the ciphertexts are shuffled and then decrypted so they cannot be traced back to the voters that produced them. Homomorphic encryption allows us to tally the votes without having to decrypt any individual vote, thereby maintaining voter privacy. Mixnets shuffle the input list of votes so that the output list cannot be traced back to the inputs; the output list may then be decrypted and the plaintexts posted on the secure bulletin board so that anyone may verify the election tally. Sections [REF NEXT 2 SECTIONS] describe each scheme in greater detail.

\subsection{Threshold Encryption}
In general, it is advisable to also use \emph{threshold encryption}, in which a minimum threshold $k$ out of a possible $n$ trustees must agree before decryption can occur. This mitigates the risk that some subset of election officials is corrupt and prevents them from decrypting individual votes.

One way to share some secret value (such as the secret key) among many parties is to use the method developed by Shamir in [CITE]. To share a secret among $n$ parties with a minimum threshold $k$, we use a polynomial $P$ of degree $k-1$ over a finite field. The secret value is set as $P(0)$; each trustee is given a point $(x, y), x \neq 0$. Because $k$ points are required to reconstruct a polynomial of degree $k-1$, any $k$ trustees will be able to recover the secret key, but fewer trustees will not be able to.

With some encryption schemes, threshold encryption may be enabled even with the use of Shamir secret sharing; for example, [CITE PEDERSEN / GENNARO] provides a way to do this with the El Gamal public-key encryption scheme.

\section{Homomorphic Encryption Schemes}

In a \emph{homomorphic encryption} scheme, a set of operations may be performed on ciphertexts to produce the encrypted result of a (possibly different) set of operations on the underlying plaintexts without the need for decryption. The usefulness of homomorphic encryption is immediately apparent in a cryptographic voting system: ciphertexts corresponding to the selections of individual voters may be tallied to yield an encryption of the election outcome without requiring that the individual votes be decrypted.

\subsection{Exponential El Gamal}

The exponential El Gamal public-key encryption is one example of a cryptosystem that supports homomorphic encryption.
\begin{definition}
\textbf{(Exponential El Gamal)}
\begin{itemize}
\item \textbf{Key Generation.} Given a group $G$ with order $q$ and generator $g$, which are public parameters, choose the secret key $k \xleftarrow{R} \{1, \dotsc, q-1\}$ and the public key $y = g^k$.
\item \textbf{Encryption.} For each plaintext message $m$, select $r \xleftarrow{R} \{1, \dotsc, q-1\}$ and construct the ciphertext $(c_1, c_2) = (g^r, g^m y^r)$.
\item \textbf{Decryption.} Given a ciphertext $(c_1, c_2)$, calculate
\begin{align*}
\log_g\left((c_1^k)^{-1} c_2\right) = \log_g\left((g^{kr})^{-1} g^m g^{kr}\right) = m
\end{align*}
\item \textbf{Homomorphic Addition of Ciphertexts.} Given two ciphertexts $C_1 = (g^{r_1}, m_1 \cdot y^{r_1})$ and $C_2 = (g^{r_2}, m_2 \cdot y^{r_2})$, componentwise multiplication yields an encryption of the sum of their underlying plaintexts with randomness $r_1 + r_2$.
\begin{align*}
C_1 \times C_2 &= (g^{r_1}, g^{m_1} y^{r_1}) \times (g^{r_2}, g^{m_2} y^{r_2}) \\
&= (g^{r_1 + r_2}, g^{m_1 + m_2} y^{r_1 + r_2})
\end{align*}
\end{itemize}
\end{definition}

\subsubsection{Tallying and Proof of Decryption}

After the votes have been tallied via homomorphic addition, the resulting ciphertext is decrypted to yield the sum of all the votes. This decrypted sum is then posted to the secure bulletin board and should be consistent with the declared election outcome. Finally, the system needs to prove that the posted decryption is a proper decryption of the ciphertext without revealing the secret key; otherwise, a voter could use the revealed secret key to prove to a coercer how she voted.

In exponential El Gamal, given public parameter $g$ and public key $y$, we want to show that plaintext $m$ is the proper decryption of ciphertext $(c_1, c_2)$. Recall that a proper encryption of the plaintext $m$ results in ciphertext $(g^r, g^m y^r)$. We divide the second component of the ciphertext by $g^m$ and then construct a proof showing that the result is of the form $(g^r, y^r) = (g^r, (g^x)^r)$. A proof of equality for two discrete logarithms, such as those described in [CHAUM/PEDERSEN] can then be used.

\subsection{Existing Systems Using Homomorphic Encryption}

Many existing end-to-end verifiable voting systems use homomorphic encryption because its implementation is rather straightforward and the cryptographic primitives used are well-supported. Despite starting with mixnets, the Helios system [CITE], which runs in a web browser and is intended for online elections where the threat of coercion is low (e.g. school or club elections), now uses exponential El Gamal. Design proposals for the STAR-Vote system in Austin County, TX [CITE] use very similar techniques as those discussed here, including the cast-or-challenge protocol, encrypted votes posted on a publicly-viewable secure bulletin board, and homomorphic tallying with exponential El Gamal. In these systems, the weaknesses of using homomorphic tallying, including the computational cost of modular exponentiation used in El Gamal and the difficulty of supporting write-in candidates, are offset by the simpplicity and clarity of the design and implementation.

\section{Mixnets}

Another way of verifying that the election result accurately reflects the set of encrypted votes is to use a \emph{mixnet}. First described by Chaum in [CITE CHAUM] as a method to ensure anonymous communication, mixnets secretly permute the list of inputs so that they cannot be associated with the list of outputs. A mixnet may involve many \emph{mixservers} that are each a part of the overall chain; each mixserver secretly permutes the output of the previous mixserver, and sends its output to the next mixserver to be permuted.

In the context of elections, the input to the mixnet is the list of encrypted votes, and the output is a list of the same votes, encrypted differently and in some different order. We can decrypt the ciphertexts that are output from the mixnet and post the resulting plaintexts to the secure bulletin board along with proofs of correct decryption. This allows anyone to check that the plaintexts produce the election outcome while making it impossible to associate each any plaintext vote with a voter.

The encryption of the votes must change between the input and output; we cannot simply shuffle the encrypted values. Otherwise an adversary could easily compare the input and output lists, find identical ciphertexts, and associate them with the voter IDs which are posted alongside the input ciphertexts on the secure bulletin board.

\subsection{Decryption and Reencryption Mixnets}

There are two general types of mixnets which accomplish our goals: \emph{decryption mixnets} and \emph{reencryption mixnets}.
\begin{itemize}
\item In a \emph{decryption mixnet}, a message is encrypted with the public key of each mixserver in the reverse order of traversal. In a system with $n$ mixservers, the input to the mixnet for message $m$ is $E_{K_n}(E_{K_{n-1}}( \dots (E_{K_1}(m))))$, where $E_{K_i}$ denotes encryption using the public key of the $i$th mixserver. At each mixserver, one layer of encryption is removed and the list of messages is shuffled before being sent to the next mixserver. The mixnet outputs a list of decrypted messages whose ordering cannot be traced back to the input ordering. Decryption mixnets are commonly used to anonymize routing in designs known as ``onion routing'', where each message is encrypted repeatedly like the layers of an onion, and each mixserver ``peels off'' a layer until the plaintext message is reached.
\item In a \emph{reencryption mixnet}, a message is encrypted once and input into the mixnet. At each mixserver, messages are reencrypted using a public-key encryption scheme that supports reencryption and then shuffled. An example of a public-key encryption scheme that supports reencryption is exponential El Gamal, as discussed in the [REF PREV SECTION], by homomorphically combining the message to be reencrypted with an encryption of the ``zero message''. This similarly achieves our goals: the underlying plaintexts do not change through the mixnet, but their ciphertext representations and ordering are changed in a way that makes the outputs untraceable to the inputs.
\end{itemize}

\subsection{Verifiable Mixnets}

A malicious mixserver might ignore the inputs given to it and send whatever list of encrypted votes it desires to the next mixserver in the chain. If the malicious mixserver were the last mixserver in the chain, it could ignore all of the ballots, decide the election outcome, and construct an output list that matches that outcome.

Thus, in addition to anonymity, we require that our mixnets are \emph{verifiable}. A verifiable mixnet is one which can produce a proof that the underlying plaintexts of the outputs are the same as the underlying plaintexts of the inputs without revealing the association between input and output. Verifiable mixnets have been studied for decades, beginning with Chaum's work in 1981 [CITE]. Here we survey some of the developments in verifiable mixnets since Chaum's work that influence the design of our split-value voting system.

\subsubsection{Attacks on Malleable Inputs}

\subsubsection{Universal Verifiability}

\subsubsection{Randomized Partial Checking}

\subsection{Existing Systems Using Mixnets}






